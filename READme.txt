项目名称 ：基于 Linux GEC6818 开发板 五子棋

项目制作人 ：黎景涛 邓艺康

项目介绍 ：
	项目实现功能：分别用数组和链表实现 棋子 横 ，竖，左上，右上，左下，右下，有五个连续相同棋子（白子或黑子）则表示（黑或白）胜出
		一丶界面设计：
		       链表五子棋的功能首先是一个捕鱼达人的游戏界面
		  1.  点击开始游戏，进入捕鱼达人的游戏界面
		  2.  点击右上角小丑鱼即可退出游戏界面，回到主界面。
		  3.  点击结束游戏，即可实现出现一个gameover界面
		  4.  然后滑动屏幕弹出真实游戏（五子棋）的提示
		  5.  即可开始下棋 
		二丶游戏设计：
		      （玩家1 是下黑子，玩家2 是下白子）
		       要遵循黑子先行的原则，（点击棋盘表示黑子要下在的位置，点击棋盘右边表示是否要悔棋，要悔棋点右边上半部分，反之点击下半部分。再次点击表示白子要下在的位置，以此类推）
		       相关函数
		LCD.h
			int lcd_init()：             打开映射与lcd屏

			void close_lcd()：       解除映射，关闭lcd屏

			int init_lcd(int color)：屏幕初始化函数，color表示要刷屏的颜色。
		my_draw.h
			int draw_point(int x, int y, int color)：    画点函数，x，y表示所需画点位置，color表示画点颜色，使用映射。

			int draw_line()：		               画线函数，通过画横线和竖线绘制棋盘，这里我绘制了一个480×480大小的棋盘
						               每条线之间相差40，故画线遍历每一个像素点并对40取余。在通过画点函数实现。

			void ChessPieces(int x, int y, int color)：画棋子函数，x，y表示所需画棋子位置，color表示画棋颜色黑或白
						               简易思路：以传入坐标x，y为圆心，合适大小为半径画圆（点亮距离圆心为半径的所有像素点）。
		bmp.h
			定义一个带头节点的双向循环链表存放图片名。
			typedef struct circle_bmp
			{
				char* name;
				struct circle_bmp* prev;
				struct circle_bmp* next;

				}BMP;
			typedef struct bmp_first
			{
				struct circle_bmp* first;
			}Bmpfirst;
			Bmpfirst* BMPS() ：		  创建一条带头节点的双向链表
			int draw_pic(int x, int y, char* pic_name)：画bmp图片函数，x，y表示在哪个坐标点开始绘制图片，pic_name表示所需绘制图片的名字
			简易思路：定义一个4字节的char数组，打开所需绘制图片文件，判断是否为bmp文件，然后读取该图片的位宽：4字节，偏移0x12 ；位高：4字节，偏移0x16；
			色深：2字节，偏移0x1C。在读取像素组的内容，在分情况讨论：如果为32色深，bmp_A位为图片本身自带数据，否则该位置0。进行位操作记录数据时顺序为BGRA。
			再通过画点函数绘制图片需注意字节对齐，故每次画点都需偏移至4的倍数。

			int ShowBmp()：			  使用延时显示多张图片的函数。
			简易思路：首先初始化屏幕，然后打开图片所在目录，创建目录操作结构体，对比目录中图片的名字，依次打印图片，并每次打印一张都需延时50微秒，并直接初始化屏幕。

			int Link_Click_changepic(Bmpfirst* B, int n);使用链表点击切换图片，B存放存入链表中的所有图片的名字，n表示需要传入多少张图片
			简易思路：首先使用while（）循环，一次存入一张图片，终止条件为存入了n张图片。使用sprintf函数将名字存入链表中。然后循环打印图片，点击左边切换上一张，点击右边
			切换下一张。当为最后一张图片时，点击回到第一张。只有当点右上角那个区域时程序才会结束。

			int Link_Fignle_changepic(Bmpfirst* B, int n)使用链表滑动切换图片，B存放存入链表中的所有图片的名字，n表示需要传入多少张图片
			简易思路：思路与点击相似，只需将判断条件变为滑动的方向即可。
			
			touch.h
				int get_coordinate(int* x, int* y)： 屏幕点击事件。*x，*y。表示获取点击屏幕的坐标位置
				简易思路：打开屏幕操作事件，创建结构体，当点击屏幕时，用*x，*y表示传回触摸的坐标。当手指松开的时候，退出此次获取。
			
				int get_fingle_move();	      屏幕滑动事件。返回划动方向
				简易思路：获取两个坐标，第一次点击的坐标只获取一次，然后实时获取第二个点的坐标，直到松开屏幕。如果两次纵坐标的差值大于两次横坐标的差值
				则表示上划或者下划。反之，则表示左划或右划。在通过判断两次纵坐标或者横坐标的大小即可分出结果。
			
			FiveChess.h
				设计一个带头节点双向循环链表存放顶点坐标，并存放该顶点信息
				typedef struct vertex
				{
					int status;//判断是否可以悔棋
					int winner;//判断是黑棋胜还是白棋胜
					int flag;//判断是否有棋的标志位
					int x;//该顶点横坐标
					int y;//该顶点纵坐标
					struct vertex* next;
					struct vertex* prev;
				}Vertex;
				typedef struct verfirst
				{
					struct vertex* first;
				}Verfirst;
			Verfirst* init_ver();创建一条双向循环链表函数。返回该链表头节点
			
			Verfirst* Hor_vertex_all();横向存放所有顶点，返回该链表的头节点
			简易思路：首先创建一条链表，创建一个新节点，头节点指向这一个节点，然后横向循环遍历每一个顶点，在创建一个新的节点存放当前顶点的信息，让其前驱指向头节点指向的
			那一个节点，头节点指向的那一个节点的后继指向该节点，再让头节点指向的那一个节点后移，直到为最后一个顶点的时候，将最后一个顶点和头节点接起来。

	
			Verfirst* Ver_vertex_all();纵向存放所有顶点，返回该链表的头节点
			简易思路：思路与横向相似，只需改变判断条件即可。
	
			Vertex* my_distance(Vertex* v, int x0, int y0, Vertex* p);比较距离大小的函数，v为所有顶点坐标，x0，y0为触摸屏获取坐标，p为存放最短距离的坐标节点
			简易思路：使用递归，终止条件为v为null，或者v为最后一个顶点。比较v到x0，y0的距离和p到x0，y0的距离，然后让p节点等于最小距离的节点然后再将p和v.next传入函数中
			int distance= (v->x - x0) * (v->x - x0) + (v->y - y0) * (v->y - y0);
			int dis= (p->x - x0) * (p->x - x0) + (p->y - y0) * (p->y - y0);
			if (dis < distance)
			{
				return my_distance(v->next,x0,y0,p);
			}
			else
			{
				p = v;
				return my_distance(v->next, x0,y0,p);
			}

			Vertex* MoveChesspiont(int* x1, int* y1);落子函数位置的函数，*x1，*y1为触摸屏幕坐标，返回落子位置的坐标
			简易思路：将顶点链表和触摸屏坐标，以及新节点传入递归函数Vertex* my_distance(Vertex* v, int x0, int y0, Vertex* p)中即可得到落子位置。
		
			int game_status(Vertex* H, Vertex* V, /*Vertex* L,*/ int winner);判断是否赢并且是黑赢还是白赢的函数
			简易思路：因为传入的是落子位置，所以让棋子先依次向后找相同的节点，并记录有几个，然后在向前找相同的节点，记录有V2，如果v2大于等于4即可说明游戏胜利
			如果传入的winner为black即黑赢反之则白赢。

			int game_winner();进行游戏并判断输赢的函数。
			简易思路：lcd初始化，画棋盘，创建链表横竖存放所有顶点。给个死循环，每次点击下棋都会判断落子位置，让一个存放顶点坐标的链表遍历找到该位置，之后进入循环
			判断该位置的flag是否为0，如果不为0，说明该位置已有棋子，给出提示信息，并重新落子，如果为0，有一个为0的标志位flag1，每成功落一个子，flag1++，每次落子
			前判断flag1对2取模，为0则下黑棋反之下白棋。每下一个棋判断游戏状态是否结束，如果没有结束，游戏继续，结束游戏停止，并输出哪一方获胜。
			
			int Rafmiacg(Vertex* v);悔棋函数。传入v表示落子位置。
			简易思路：点击棋盘右边上半部分表示悔棋，下半部分表示不悔棋。先将落子位置的棋子画成原来的背景色，在写一个算法实现只画被棋子盖住的横竖两条线。
			
		三丶主要BUG与解决方法
			1.因为是使用链表进行操作，故出现多次段错误
			解决办法：调试，使用printf（“ ***  \n”）；直到确定是哪一行出现错误，判断是否越界，是否出现空指针野指针的情况。
			为避免这种情况，每次建立指针时都必须进行初始化。
			2.如何判断顶点上有无棋子
			解决思路：在存放顶点的结构体中新设一个标志位，每次落子时判断必须先判断该标志位是否为0。如果不为0则不能下棋。
			且但也算点击了一次所以需要将决定是黑棋还是白棋的标志位加一。如果该标志位为一说明该顶点已有棋子。


	主要用到工具：Visual Studio Code ,VMware Workstation 16 Player,SecureCRT,GEC6818 开发板,网线

	      Visual Studio Code ：主要实现代码的编写
	           主要分为 ：图片显示部分 ，按键部分，五子棋判断胜出部分，图片像素点部分等等
	    
	     VMware Workstation 16 Playe ：主要实现代码编译	           
	         Code写好的代码存入共享文件夹share内，Ubuntu找到这个共享文件夹路径进行 make 编译 ，编译好的 arm-linux 可执行文件存入
	         /home/china/tftpboot文件中。

	    网线 ：Ubuntu 和 SecureCRT 形成局域网进行文件传输

	主要实现将可执行文件传入GEC6818 开发板
                         根据 tftp -g -r 文件名 Ubuntu网址指令，使用telnet命令使虚拟机的终端变成开发板。将 Ubuntu 内 tftpboot 里面的文件 经过网线传输到开发板 ，然后执行可执行文件下载到
	         GEC6818 开发板

	 GEC6818 开发板：显示效果
