项目日志：
1.创建makefile文件，便于管理工程。
2.了解lcd的基本使用方式，尝试通过映射打开lcd
映射头文件#include<sys/mman.h>
如果打不开使用perror输出错误信息,引用头文件#include<errno.h>
3.写出对应的解除映射函数关闭lcd函数
4.将要显示的图片放入pic文件夹中
一：lcd
1.1
首先编写打开映射，lcd屏的函数，将plcd设置为全局变量
1.2
编写关闭lcd屏的函数，解除映射，方便后面调用

二：编写画背景图函数封装在my_draw.c中
1.1
编写画点函数，使用映射方式。所需参数：x，y，color；表示在哪一个点画什么颜色
1.2
通过画点函数编写画线函数用横线竖线构成一个棋盘
这里绘制一个大小为480*480的棋盘每一各xy均为40
问题：画一行像素点的线无法被肉眼识别
解决办法：设置一个标志位flag将三行捆绑在一起
竖线同理。
1.3
编写生成棋子函数：所需参数：x,y,color;表示在哪一个点生成什么颜色的棋子
为了方便计算且大小合适故选取每一格的五分之一为圆的半径

三.将画bmp图函数封装在bmp.c中
尝试写了一个画图函数，遇到了很大的问题，进度卡顿。
问题一：
指针的内容和字符串内容不能直接用等号比较，要使用strcmp函数！
问题二：
只刷白屏，不显示图片
尝试一：将fd设为全局变量
尝试二：将write改为映射
尝试三：重新了解画图的过程，重新写了一个画图函数。
先读取图片的信息，再通过画点函数进行绘制。可以实现图片的打印但是图片被斜切

解决昨天晚上问题的办法：
对bmp的每一个像素点的每一个字节进行位操作读取对应颜色
问题一：读取每一位时存入char变量中，而不能直接存入color里
错误示范：
char bmp_R, bmp_B, bmp_A, bmp_G;
	for (i = bmp_h; i >= 0; i--)
	{
		for (j = 0; j < bmp_w; j++)
		{
			int color = 0;
			if (bmp_colordepth == 32)
			{
				//读完后光标会自动移动到末尾位置
		!!!!!!!!!!错误示范：	bmp_B=read(fd1, &color, 1);
		正确应该这样：	read(fd1, &bmp_B, 1);
				read(fd1, &bmp_G, 1);
				read(fd1, &bmp_R, 1);
				read(fd1, &bmp_A, 1);
				color = bmp_A << 24 | bmp_R << 16 | bmp_G << 8 | bmp_B;
				draw_point(x + j, y + i, color);
			}
问题二：对bmp像素点记录数据顺序不了解，导致刷图颜色不对。
解决办法：多次尝试，发现bmp像素点记录数据为蓝绿红透明度，即BGRA
对于32位的bmp图片，A就为他本身的A，如果是24位的bmp图片，要将A置0。

思考存放多张图片的办法：
初步思路：用目录打开文件，给多张图片依次命名1.bmp；2.bmp...；
对图片进行循环遍历，使用延时进行刷图显示。
	while (dirp = readdir(dir))
	{

		if (strcmp(dirp->d_name, "1.bmp") == 0)
		{
			draw_pic(200, 40, dirp->d_name);
		}
		usleep(50);
		init_lcd();
		if (strcmp(dirp->d_name, "2.bmp") == 0)
		{
			draw_pic(200, 40, dirp->d_name);
		}
		usleep(50);
		init_lcd();
		if (strcmp(dirp->d_name, "3.bmp") == 0)
		{
			draw_pic(200, 40, dirp->d_name);
			break;
		}
	}
问题：延时不能太大，否则刷不出图片，故使用50微秒

四：触摸屏事件
尝试使用触摸屏事件，实现点击一下屏幕切换一张图片。
思路：
首先实现触摸屏事件：设备名为：/dev/input/event0，头文件为：linux/input.h
问题：容易出现使用野指针的情况
解决方法，每使用一个指针必须对其进行初始化
通过使用sprintf函数和%d，实现点击一下屏幕切一张图片
int i,x,y;
init_lcd();
char* name = (char*)malloc(sizeof(name));
//ShowBmp();
for (i = 1; i <= 3; i++)
{
	sprintf(name, "%d.bmp", i);
	get_coordinate(&x,&y);
	draw_pic(200, 40, name);
	get_coordinate(&x, &y);
	init_lcd();
	printf("x=%d y=%d", x, y);
}
思路：实现图片来回切换，点左半边实现回退，右半边实现下一张。
思路：可以通过触摸屏函数返回的坐标判断在左半边还是右半边，然后通过控制%d的值来实现切换。
出现一点点问题：可以来回切换，但是当图片为最后一张时，程序结束了。
解决思路：当图片为最后一张时将i置一
新思路：给一个死循环来回切换，设置一个小小的xy坐标范围，当触摸到那个范围时，退出程序。
编写实现滑动屏幕功能函数
思路：使用双向循环链表实现功能
问题：sprintf函数的用法有误
存字符串的指针必须有一块空间，不能是空地址！！！！

五：实现五子棋的基本功能
封装入FiveChess.c中
落子位置函数：当触摸位置距离哪个顶点最近，就在那个顶点生成棋子
通过实验编写发现带头节点的双向链表存放所有顶点比较方便
首先写一个比较距离大小的函数
Vertex* my_distance(Vertex* v, int x0, int y0, Vertex* p)
参数中结构体p为存放最短距离的节点的地址。
x0，y0为触摸屏点击的坐标
结构体v存放所有顶点的坐标
故可以使用递归实现
if (v == NULL)
{
	return p;
}
if (v->next == NULL)
{
	return p;
}
int distance= (v->x - x0) * (v->x - x0) + (v->y - y0) * (v->y - y0);
int dis= (p->x - x0) * (p->x - x0) + (p->y - y0) * (p->y - y0);
if (dis < distance)
{
	return my_distance(v->next,x0,y0,p);
}
else
{
	p = v;
		return my_distance(v->next, x0,y0,p);
}
然后初始化一个结构体头节点
编写落子函数
Vertex* MoveChesspiont(int* x1, int* y1);
将所有的顶点存入结构体V中，用x1，y1输入触摸屏触摸的坐标，返回所有的顶点节点

写一个函数判断输赢
问题：如何判断顶点上有无棋子
解决思路：在存放顶点的结构体中新设一个标志位，每次落子时判断必须先判断该标志位是否为0
如果不为0则不能下棋。且但也算点击了一次所以需要将决定是黑棋还是白棋的标志位加一。
如果该标志位为一说明该顶点已有棋子。
因为所有的顶点都存放在结构体中，所以遍历一遍结构体，如果标志位为1，并且有五个连续x相同
或者五个连续y相同，或者五个连续x和y都相差40的情况出现说明游戏结束。

实现步骤：
经过实验，发现将落子函数变为只求落子位置更好，并且将落子位置传回。
通过在结构体中设标志位的方式，可以实现在落子前判断该位置是否有棋
如果有则提示错误信息，并重新下棋。
问题：因为传位置他传的位置的标志位都为0，没有考虑更改标志位
所有标志位没有用。
解决方法：
经过实验发现用双向循环链表更适合存放所有顶点
重新封装一个函数获取所有顶点，然后先判断是否可以落子
在判断下黑棋还是白棋
判断输赢：
先判断x轴相等，得先判断是否有x轴上五个连一起的五子
在判断是否为一样的棋
在判断y轴相等，同理
思路：写三条链表，一条黑棋，一条白棋，一条顶点。
思路不通。
另一思路：写四条链表分别横向存放所有顶点，竖向存放所有顶点
左对角右对角存放所有顶点，然后记录每一个链表上的落子信息，让其走到一端后在回头满足>5即可实现
bug：没有判断是否在同一条线上，所有有一点问题
解决办法：锁定落子所在范围的线。
成功实现横竖功能。
添加图片，增加趣味性。
添加了一个悔棋功能。


